<%~ includeFile('../../header.eta', it) %>

package services

import (
	"context"
	"errors"

	"app/dto"
	"app/models"
	"gorm.io/gorm"
)

type <%= it.entityName %>Service struct {
	db *gorm.DB
}

func New<%= it.entityName %>Service(db *gorm.DB) *<%= it.entityName %>Service {
	return &<%= it.entityName %>Service{db: db}
}

// FindAll retrieves a paginated list of <%= it.pluralName %>
func (s *<%= it.entityName %>Service) FindAll(ctx context.Context, page, pageSize int) (*dto.<%= it.entityName %>PaginatedResponse, error) {
	var total int64
	var items []models.<%= it.entityName %>

	offset := (page - 1) * pageSize

	if err := s.db.WithContext(ctx).Model(&models.<%= it.entityName %>{}).Count(&total).Error; err != nil {
		return nil, err
	}

	query := s.db.WithContext(ctx)
<% it.associations.filter(a => a.eager).forEach((assoc) => { %>
	query = query.Preload("<%= assoc.referenceName || assoc.name %>")
<% }) %>
	if err := query.Offset(offset).Limit(pageSize).Find(&items).Error; err != nil {
		return nil, err
	}

	totalPages := int(total) / pageSize
	if int(total)%pageSize > 0 {
		totalPages++
	}

	response := make([]dto.<%= it.entityName %>Response, len(items))
	for i, item := range items {
		response[i] = s.toResponse(&item)
	}

	return &dto.<%= it.entityName %>PaginatedResponse{
		Data:       response,
		Total:      total,
		Page:       page,
		PageSize:   pageSize,
		TotalPages: totalPages,
	}, nil
}

// FindOne retrieves a single <%= it.entityName %> by ID
func (s *<%= it.entityName %>Service) FindOne(ctx context.Context, id string) (*dto.<%= it.entityName %>Response, error) {
	var item models.<%= it.entityName %>

	query := s.db.WithContext(ctx)
<% it.associations.filter(a => a.eager).forEach((assoc) => { %>
	query = query.Preload("<%= assoc.referenceName || assoc.name %>")
<% }) %>

<% if (it.primaryKeyType === 'uuid') { %>
	if err := query.Where("id = ?", id).First(&item).Error; err != nil {
<% } else { %>
	if err := query.First(&item, id).Error; err != nil {
<% } %>
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, errors.New("<%= it.entityName %> not found")
		}
		return nil, err
	}

	response := s.toResponse(&item)
	return &response, nil
}

// Create creates a new <%= it.entityName %>
func (s *<%= it.entityName %>Service) Create(ctx context.Context, input *dto.<%= it.entityName %>Create) (*dto.<%= it.entityName %>Response, error) {
	item := models.<%= it.entityName %>{
<% it.columns.filter(c => !c.generated && !c.primary).forEach((column) => { %>
<% if (column.required) { %>
		<%= column.pascalName %>: input.<%= column.pascalName %>,
<% } else { %>
		<%= column.pascalName %>: input.<%= column.pascalName %>,
<% } %>
<% }) %>
<% it.associations.filter(a => a.type === 'ManyToOne' || (a.type === 'OneToOne' && a.isOwner)).forEach((assoc) => { %>
		<%= assoc.referenceName || assoc.name %>ID: input.<%= assoc.referenceName || assoc.name %>ID,
<% }) %>
	}

	if err := s.db.WithContext(ctx).Create(&item).Error; err != nil {
		return nil, err
	}

	response := s.toResponse(&item)
	return &response, nil
}

// Update updates an existing <%= it.entityName %>
func (s *<%= it.entityName %>Service) Update(ctx context.Context, id string, input *dto.<%= it.entityName %>Update) (*dto.<%= it.entityName %>Response, error) {
	var item models.<%= it.entityName %>

<% if (it.primaryKeyType === 'uuid') { %>
	if err := s.db.WithContext(ctx).Where("id = ?", id).First(&item).Error; err != nil {
<% } else { %>
	if err := s.db.WithContext(ctx).First(&item, id).Error; err != nil {
<% } %>
		if errors.Is(err, gorm.ErrRecordNotFound) {
			return nil, errors.New("<%= it.entityName %> not found")
		}
		return nil, err
	}

	updates := make(map[string]interface{})
<% it.columns.filter(c => !c.generated && !c.primary).forEach((column) => { %>
	if input.<%= column.pascalName %> != nil {
		updates["<%= column.snakeName %>"] = *input.<%= column.pascalName %>
	}
<% }) %>
<% it.associations.filter(a => a.type === 'ManyToOne' || (a.type === 'OneToOne' && a.isOwner)).forEach((assoc) => { %>
	if input.<%= assoc.referenceName || assoc.name %>ID != nil {
		updates["<%= assoc.snakeReferenceName || assoc.snakeName %>_id"] = *input.<%= assoc.referenceName || assoc.name %>ID
	}
<% }) %>

	if len(updates) > 0 {
		if err := s.db.WithContext(ctx).Model(&item).Updates(updates).Error; err != nil {
			return nil, err
		}
	}

	// Reload with associations
	query := s.db.WithContext(ctx)
<% it.associations.filter(a => a.eager).forEach((assoc) => { %>
	query = query.Preload("<%= assoc.referenceName || assoc.name %>")
<% }) %>
<% if (it.primaryKeyType === 'uuid') { %>
	if err := query.Where("id = ?", id).First(&item).Error; err != nil {
<% } else { %>
	if err := query.First(&item, id).Error; err != nil {
<% } %>
		return nil, err
	}

	response := s.toResponse(&item)
	return &response, nil
}

// Delete removes a <%= it.entityName %> by ID
func (s *<%= it.entityName %>Service) Delete(ctx context.Context, id string) error {
<% if (it.primaryKeyType === 'uuid') { %>
	result := s.db.WithContext(ctx).Where("id = ?", id).Delete(&models.<%= it.entityName %>{})
<% } else { %>
	result := s.db.WithContext(ctx).Delete(&models.<%= it.entityName %>{}, id)
<% } %>
	if result.Error != nil {
		return result.Error
	}
	if result.RowsAffected == 0 {
		return errors.New("<%= it.entityName %> not found")
	}
	return nil
}

// toResponse converts a model to a response DTO
func (s *<%= it.entityName %>Service) toResponse(item *models.<%= it.entityName %>) dto.<%= it.entityName %>Response {
	return dto.<%= it.entityName %>Response{
		ID: item.ID,
<% it.columns.forEach((column) => { %>
		<%= column.pascalName %>: item.<%= column.pascalName %>,
<% }) %>
<% if (it.createdAt) { %>
		CreatedAt: item.CreatedAt,
<% } %>
<% if (it.updatedAt) { %>
		UpdatedAt: item.UpdatedAt,
<% } %>
<% it.associations.filter(a => a.type === 'ManyToOne' || (a.type === 'OneToOne' && a.isOwner)).forEach((assoc) => { %>
		<%= assoc.referenceName || assoc.name %>ID: item.<%= assoc.referenceName || assoc.name %>ID,
<% }) %>
	}
}
