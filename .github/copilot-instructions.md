# Apso CLI AI Coding Instructions

## Project Overview

**Apso CLI** (`@apso/cli`) is a schema-first code generation tool that produces production-ready NestJS backends with TypeORM and REST/GraphQL APIs from `.apsorc` configuration files.

**Key Values:**
- Schema-driven development (single source of truth in `.apsorc`)
- Auto-generation of entities, services, controllers, DTOs, and guards
- Multi-tenant data scoping via `scopeBy` configuration
- Support for REST and GraphQL APIs
- Role-based access control extensibility

---

## Architecture Overview

### Core Generation Pipeline

1. **Parse `.apsorc`** → `parseApsorc()` in `src/lib/apsorc-parser.ts`
   - Supports v1 (entity.associations) and v2 (explicit relationships)
   - Returns: `{ entities, relationshipMap, apiType, auth }`
   - v1 only supports REST; v2 supports both REST and GraphQL

2. **Build Generated Files** → `src/commands/server/scaffold.ts`
   - Calls `createEntity()`, `createService()`, `createController()`, `createModule()` for each entity
   - Parallel processing for performance (see DEBUG timing logs)
   - Outputs to `src/autogen/{EntityName}/` directory

3. **Template Rendering** → Eta templating engine in `src/lib/templates/`
   - REST templates: `src/lib/templates/rest/`
   - GraphQL templates: `src/lib/templates/graphql/`
   - All generated files include header comment: `/* Generated by Apso - do not edit */`

### Key Data Flow

```
.apsorc → parseApsorc()
         → RelationshipMap { [entityName]: Relationship[] }
         → createEntity() / createService() / createController() / createModule()
         → src/autogen/{EntityName}/{Entity.service.ts, Entity.controller.ts, etc.}
```

### Configuration Files

- **`.apsorc`** – Schema definition (required, v2 format recommended)
- **`apsorc.schema.json`** – JSON Schema validator for `.apsorc`
- **`backend-rules.md`** – Developer guidelines (extension patterns, do/don't practices)

---

## Critical Patterns & Conventions

### 1. Schema Version Differences

**v1 Format** (Legacy, REST-only):
```typescript
// entities[].associations - inline relationship definitions
associations: [{ type: "OneToMany", name: "posts" }]
```

**v2 Format** (Current, REST + GraphQL):
```typescript
// Explicit relationships array
relationships: [
  { from: "User", to: "Post", type: "OneToMany", to_name: "posts" },
  { from: "Post", to: "User", type: "ManyToOne" }
]
```

- Parse v1 with `parseApsorcV1()` → converts associations to relationships
- Parse v2 with `parseApsorcV2()` → uses relationships directly

### 2. Relationship Handling

**RelationshipMap** structure (in `src/lib/types/relationship.ts`):
```typescript
type RelationshipMap = { [entityName: string]: Relationship[] }
// Relationship: { name, type, referenceName?, nullable?, cascadeDelete?, joinTableName? }
```

**Key conversion functions** in `src/lib/utils/relationships/`:
- `getRelationshipForTemplate()` – Transforms relationships into template-friendly format
- `streamNestedRelationships()` – Recursively collects related entities for deep relationship generation
- Outputs `RelationshipForTemplate` with computed names (pluralized, camelCased, etc.)

### 3. Multi-Tenant Scoping via `scopeBy`

**Entity-level configuration:**
```typescript
{
  name: "Post",
  scopeBy: ["workspaceId"] // Direct field
  // OR
  scopeBy: ["workspace.id"] // Nested path through relationship
}
```

**Scope enforcement generation** (`src/lib/guards.ts`):
- `createGuards()` generates TypeORM decorators and route guards
- `getScopedEntities()` extracts scoped configs for template rendering
- Each scoped entity gets WHERE clause injection on queries
- `scopeOptions` controls: `injectOnCreate`, `enforceOn` operations, `bypassRoles`

### 4. File Generation Functions

| Function | Output | Key Parameters |
|----------|--------|-----------------|
| `createEntity()` | `{Entity}.entity.ts` | entity, relationships, apiType, allEntities |
| `createService()` | `{Entity}.service.ts` + spec | relationshipMap for related entity imports |
| `createController()` | `{Entity}.controller.ts` + spec | relationshipMap for nested relationship handling |
| `createDto()` | Create/Update DTOs | relationships, apiType, allEntities |
| `createModule()` | `{Entity}.module.ts` | apiType (determines REST vs GraphQL template) |
| `createGuards()` | Scope enforcement guards | entities with scopeBy configuration |

All use `Eta.renderFileAsync()` with templates from `src/lib/templates/`.

### 5. Template Organization

```
src/lib/templates/
├── header.eta                    # Generated file comment header
├── rest/                         # REST API templates
│   ├── entity-rest.eta
│   ├── service-rest.eta
│   ├── controller-rest.eta
│   ├── module-rest.eta
│   ├── dto-create.eta
│   └── ...
├── graphql/                      # GraphQL templates
│   ├── entity-gql.eta
│   ├── resolver-gql.eta
│   ├── module-graphql.eta
│   ├── gql-dto.eta
│   └── ...
└── guards/                       # Scope enforcement
    └── scope-enforcement.eta
```

Template data objects always include `generatedAt` and `generatedBy` from `withGeneratedMeta()`.

### 6. API Type Routing

**In code generation:**
```typescript
switch (apiType.toLowerCase()) {
  case "rest":
    await createService();     // Service with @Injectable
    await createController();  // Controller with @Controller routes
    await createDto();         // Create/Update DTOs
    break;
  case "graphql":
    await createGqlDTO();      // GraphQL input/output types
    await createResolver();    // Resolver with @Query/@Mutation
    break;
}
```

---

## Critical Developer Workflows

### Build & Test

```bash
npm run build              # Compile TypeScript
npm test                   # Jest tests (ts-jest preset)
npm run scaffold          # Generate code from .apsorc
npm run format            # Prettier formatting
```

### Local Development

```bash
npm link                           # Link CLI globally
apso server new --name myapp       # Create boilerplate
apso server scaffold               # Generate backend code
npm run compose                    # Start Docker Postgres
npm run provision                  # Run migrations
```

### Debugging

- **`DEBUG=true apso server scaffold`** – Enable timing logs and memory usage
- **Performance profiling:** Functions log `[timing]` and `[mem]` metrics
- **Relationship complexity:** Use `streamNestedRelationships()` to diagnose deep nesting issues
- **Schema validation:** Load `.apsorc` into apsorc.schema.json validator

### Testing Patterns

- **Template tests** (`src/tests/templates/`): Use `runTemplateTests()` utility with assertions
- **Parser tests** (`test/lib/apsorc-parser/`): Mock `.apsorc` configs and verify RelationshipMap
- **Coverage exclusions:** Index files and test templates excluded from coverage

---

## Project-Specific Conventions

### File Naming
- Entities: PascalCase → `User.entity.ts`
- Services/Controllers: PascalCase → `User.service.ts`, `User.controller.ts`
- DTOs: `{Entity}Create.dto.ts`, `{Entity}Update.dto.ts`
- Spec files: `.service.spec.ts`, `.controller.spec.ts`

### Relationship Naming
- Many-to-many join tables: `{EntityA}{EntityB}` (customizable via `joinTableName`)
- Foreign key column: `{relationshipName}Id` (customizable via `joinColumnName`)
- Relation property: camelCase plural when appropriate (e.g., `posts`)

### Extension Pattern (DO NOT modify `/autogen/`)

```typescript
// src/extensions/User/User.service.ts
import { Injectable } from '@nestjs/common';
import { UserService as AutogenUserService } from '../../autogen/User/User.service';

@Injectable()
export class UserService extends AutogenUserService {
  // Add custom methods here - they won't be overwritten
}
```

### Scope Field Path Resolution

- **Direct field:** `"workspaceId"` → SELECT * WHERE workspaceId = ctx.workspaceId
- **Nested path:** `"task.workspaceId"` → JOIN task ON ... WHERE task.workspaceId = ctx.workspaceId
- Parser in `guards.ts`: `parseScopeBy()` handles both cases

---

## External Dependencies & Integration Points

### Key NPM Packages
- **`@oclif/core`** – CLI framework (commands, flags, args)
- **`eta`** – Template engine (renderFileAsync for code generation)
- **`rc`** – Configuration file parser (reads .apsorc)
- **`typeorm`** – ORM (entity decorators generated in templates)
- **`@nestjs/common`** – NestJS decorators/imports

### Integration Points
- `.apsorc` file format (JSON, validated against apsorc.schema.json)
- Platform schema conversion (`src/lib/schema-converter/`) for import/export
- Database schema hash tracking (`src/lib/schema-hash/`) for change detection
- OAuth integration hooks (`src/lib/auth/oauth.ts`)

---

## Testing & Validation

### Test Structure
```
test/
├── apsorc-json/          # Sample .apsorc files (v1, v2, ManyToMany, PostGIS)
├── helpers/              # Jest setup
└── lib/                  # Parser and utility tests

src/tests/
└── templates/            # Template rendering tests
```

### Running Tests
```bash
npm test                              # All tests
npm test -- --testPathPattern=apsorc  # Only parser tests
npm test -- --coverage               # With coverage report
```

### Key Test Utilities
- `template-test-utils.ts` – Framework for template assertion testing
- `configureEta()` – Initialize Eta for template tests
- `TemplateTestCase` – Define field input and expected outputs

---

## Common Pitfalls & Solutions

| Problem | Cause | Solution |
|---------|-------|----------|
| "GraphQL is not supported for v1" | Using v2 features with v1 schema | Upgrade `.apsorc` to `"version": 2` |
| Autogen files keep reverting | Editing in `/autogen/` directly | Use `/extensions/` directory for custom code |
| Circular relationships | Complex ManyToMany structures | Use explicit join entities instead |
| Scope enforcement not working | `scopeBy` field doesn't match entity | Verify `scopeBy` path exists in schema |
| Performance degradation | Large nested relationships | Use DEBUG logs to identify slow entity builds |

---

## Repository Context

- **CLI Type:** oclif-based CLI application
- **Language:** TypeScript with strict mode
- **Package:** `@apso/cli` (NPM)
- **Template Engine:** Eta (not Handlebars, Nunjucks, EJS)
- **Database:** PostgreSQL (TypeORM)
- **Backend Framework:** NestJS
- **Current Branch:** PLAT-1288

---

## Quick Reference

**When modifying code generation:**
1. Check if both v1 and v2 `.apsorc` formats need support
2. Decide REST vs GraphQL handling (check `apiType.toLowerCase()`)
3. Use Eta templates for multi-language output
4. Include `withGeneratedMeta()` header in all generated files
5. Test with sample schemas in `test/apsorc-json/`
6. Profile with `DEBUG=true` for performance-critical changes

**When debugging:**
1. Inspect RelationshipMap structure
2. Check template data transformations (especially casing)
3. Verify scope field paths resolve correctly
4. Use `streamNestedRelationships()` for deep relationship issues
5. Review generated spec files to ensure relationships are tested

